---
title: "Applications and Practice of Data Science. Lab 01. Interfaces and Shiny"
output:
  html_document: default
  word_document: default
---

### Интерфейсы

Пользователям не часто хотят знать, как все устроено внутри вашего сервиса / приложения и т.д. Им нужен понятный инструмент, чтобы с ним работать (какие данные внести и как получить результат). Например, [так](https://shiny.rstudio.com/gallery/google-charts.html) или [так](https://mbienz.shinyapps.io/tourism_dashboard_prod/)

Интерфейс – совокупность возможностей, способов и методов взаимодействия двух систем или  устройств для обмена информацией между ними

Пользовательский интерфейс – разновидность интерфейсов, в котором одна сторона представлена человеком

Одна из возможных технологий при работе с R -- Shiny

### Введение в Shiny

Одним из методов представления результатов исследования является создание интерактивных веб-приложений. Технология Shiny, разработанная в RStudio, позволяет создавать такие приложения, не требуя при этом каких-либо навыков веб-программирования, однако обладая такими навыками, можно получить гораздо более детально настроенные приложения. 

* Больше информации <https://shiny.rstudio.com/>
* Традиционный [cheatsheet](https://www.rstudio.com/wp-content/uploads/2016/01/shiny-cheatsheet.pdf). И его новая [версия](https://github.com/rstudio/cheatsheets/raw/master/shiny.pdf)
* Примеры для вдохновения  можно посмотреть [здесь](https://shiny.rstudio.com/gallery/) и [здесь](https://www.rstudio.com/products/shiny/shiny-user-showcase/)

#### Как все устроено

Приложение на Shiny -- это пользовательский интерфейс (в виде веб-страницы) (User Interface, UI), связанный со скриптом R, реализующим всю функциональность (Server). Т.е. есть **интерфейс**, в котором описано, как все выглядит для пользователя, и есть **сервер**, который описывает, как все работает (как построить график, как посчитать, что рекомендуется конкретному пользователю и т.д.)

Есть два способа структурировать файлы при создании приложений Shiny

1) Все в одном файле. Обязательно создаются объекты `ui` и `server` (названия менять нельзя). Название файла = app.R (и только так!)
2) Код сервера сохраняется в файл `server.R`, интерфейса -- `ui.R` (названия менять опять же нельзя). Оба файла хранятся в одной папке.

Оба варианта взаимозаменяемы. Второй более удобен, если приложение сложное и кода много.

![](https://pp.vk.me/c836430/v836430093/1c61f/wmlJ5E117h8.jpg)

#### Создание приложения

File -> New File -> Shiny Web App

По умолчанию создается пример с гистограммой. 

Чтобы запустить приложение нужно либо нажать кнопку **Run App** (справа сверху), либо выполнить код `runApp("путь к папке с приложением")`

**Попробуем:** запустите приложение

#### Интерфейс

Посмотрим на интерфейс. В нем есть заголовок (titlePanel) и "все остальное", разделенное на боковую панель (sidebarPanel) и основную панель (mainPanel). На боковой панели размещен элемент "ползунок" (sliderInput), на основной -- место для вывода графика (plotOutput).

Т.е. структура вложенная, состоящая из так называемых контейнеров (страница - главная часть - боковое меню - слайдер). Если в одном контейнере несколько элементов, то они разделяются запятыми

Типов элементов много, выбираем те, что нужны <https://shiny.rstudio.com/gallery/widget-gallery.html> + элементы, не требующие каких-то действий (картинки, линии и т.д.)

**Попробуем:** добавим после слайдера линию  (`hr()`) и поле для ввода числа (`numericInput()`). Важно (!): аккуратнее со скобками и запятыми -- не запутайтесь.

У элементов, с помощью которых вводим значения (поля для ввода, слайдеры, чекбоксы и т.д.) и у элементов, в которых мы показываем результат (график, таблица и т.д.), обязательно указываются имена -- Id (первый параметр при создании). С помощью этих имен можно обращаться к этим элементам при описании логики действий приложения -- либо "забирать" с них данные, либо отображать в них результат.

Кроме того, у каждого такого элемента есть параметры, указание которых обязательно (иначе будет ошибка при запуске). Их можно узнать по описанию функции в справке или шпаргалке. Например, для `numericInput()`:  

numericInput(**inputId, label, value,** min = NA, max = NA, step = NA, width = NULL).

Параметры, для которых не указано значение (в данном случае -- `inputId`, `label`, `value`), обязательны.

Пока мы просто добавили элементы в интерфейс, они никак не связаны с кодом, выполняющим действия, поэтому наши изменения никак не влияют на отображаемый результат.

#### Сервер

Все элементы для ввода данных хранятся в списке `input`, для вывода -- `output`. Поэтому для отображения результата (например, графика) мы сохраняем итог наших действий (код, рисующий график) в соответствующий объект. В нашем примере -- `output$distPlot`, где distPlot -- имя, которое мы задали при создании элемента для отображения графика в ui.

Между тем, какого типа элемент для вывода результата добавляется в UI, и тем, какая функция используется на сервере для создания этого результата, есть соответствие.

![](https://pp.vk.me/c836430/v836430093/1c63d/tvpp6uUS4yU.jpg)

Для получения значений с элементов ввода используется список input. Так в примере, input$bins -- это значение, указанное пользователем на слайдере.

**Попробуем:** изменим код так, чтобы цвет гистограммы менялся при изменении значений в числовом поле.

Посмотрим подробнее на работу сервера на примере [кластеризации](http://shiny.rstudio.com/gallery/kmeans-example.html)

**Продолжим с базовым примером:** 
 * добавьте элемент для вывода текста на главную панель (textOutput()). В этот элемент будем выводить фразу "Разбиение на Х столбцов", где Х -- текущие значение для bins
 * какая серверная функция соответствует выводу в textOutput? Добавьте ее в пример 

```{r eval = F}
   ...
   output$text = renderText({
     paste("Разбиение на", input$bins, "столбцов") 
   })
   ...
```


**Общие принципы создания приложения:**

1) Определите, что делает ваше приложение (начинаем именно с идеи)

2) Определите, что будет конечным результатом (график, таблица со статистикой, текстовая рекомендация, что-то еще) -- это будут элементы output

3) Определите, что должен будет ввести пользователь и в какой форме -- это будут элементы input

4) Придумайте, как элементы будут расположены на экране, какие будут значения по умолчанию, какие будут ограничения и т.д. -- т.е. разработайте интерфейс (ui). Понятно, что все может меняться в процессе разработки, но с чего-то нужно начинать

5) Реализуйте логику работу на серверной части (server)

Как и многое, что мы обсуждали раньше -- это циклический процесс, не линейный. Выполняется один шаг, что-то правится, добавляются новые элементы и т.д.

### Ваша очередь:

#### Задание 1

Экпериментируем. Для простоты возьмем лабораторную из прошлого семестра про кластеризацию. А точнее -- часть про иерархическую кластеризацию. Вынесем нужный код

```{r}
Arrests <-USArrests
scaledArrests <- scale(Arrests[,1:4])

hc.average=hclust(dist(scaledArrests), method="average")
plot(hc.average, main="Average Linkage", xlab="", sub="", cex=.9)
hc.single=hclust(dist(scaledArrests), method="single")
plot(hc.single, main="Single Linkage", xlab="", sub="", cex=.9)
hc.complete=hclust(dist(scaledArrests), method="complete")
plot(hc.complete,main="Complete Linkage", xlab="", sub="", cex=.9)

hclusters = cutree(hc.complete, 3)
```

Небольшое дополнение -- границы вокруг кластеров
```{r}
plot(hc.complete,main="Complete Linkage", xlab="", sub="", cex=.9)
rect.hclust(hc.complete, k = 3, border = 2:4)
```

Теперь создаем приложение.

1) Хотим: вывод графика с дендрограммой. Пользователь может менять число кластеров и тип ссылки (complete, average, single)
2) output: ?
3) input: ?
4) Берем за основу приложение по умолчанию и исправляем

#### Задание 2

Выберите любую лабораторную за два года. Выделите в ней задачу для визуализации. Представьте ее в виде приложения.

Например:

* лабораторная про интерпретацию ансамблей, ICE графики. Приложение позволяет выбирать переменную, по которой строится график. Если вы оставляете только одну модель, не забудьте удалить из кода все остальные
* лабораторная про центральности в сетях, данные про семьи Флоренции. Приложение позволяет выбирать разные метрики центральности и в зависимости от них менять размер вершины
